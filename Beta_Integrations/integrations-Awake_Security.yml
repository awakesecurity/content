commonfields:
  id: Awake Security
  version: -1
name: Awake Security
display: Awake Security
category: Network Security
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADwdJREFUeAHtWnt0ldWVP4/vcW/CU6DmNUgrFNPwygNERUthsIMKtGgSIIBtmbEPxZnSTtcoA70FtcvaKdNBqQXXtGuAjBoVRlBXixV5VjQPxERlFToO5IUOBDDJvfd7nDO/c+FL7osYbmGt+eM7a305r332d+7v7L3P3vsLIX7xEfAR8BHwEfAR8BHwEfAR8BHwEfAR8BHwEfAR8BHwEfAR8BHwEfAR8BG4ugjQv4R94dqnxwSprKaMmnZndNGRx/6+8S/h56+98ghkfMBFodAAg414gxv6ZCIJEbb9QVREpzWFVpy58tv0OWaKAMt0ISHXjKSUTpSuS6TrEM00C3Vqrsicn7/yaiCQ8QHzzuj/ECIbKeOxfbmOQ7jGHhi3dl3h1diozzMzBDI20ep1xWvXz6Xc2E6FAB9JuK4T27Kea1h1/4LMtnP5qwrKFk8nlE4gghxqrtt8KB2HvLKqWwjlE0mY72ht/M3JZJqionLjTJZRQVwq82jW83V1G+1kmrwJ5WOJmT1ThsO72xqf+yB5XvXzSyrv0pg5Khp232hv2vp+Ohpv7Nrxi76gB4yZjh3Z1X742Y+8ca/OKa6czTi/3rXCz586su1jb3xEUfkAwwxOh9kMUEJxOSYWSSQVRH7c1lC9V81krMFqcYN7eqd0nJ1c11SXuLZDGNfumfjor74aG7jKf0aOXzSUULJF081f4rc+M2rUNwLpXsklrTKN4FMkYC9PN386qE/SmL5Z07UtreL8xHQ0XDcfNnXjKW5o09LNjyhZPJoy4zmqG+u1LPovhIT6xFYL0OW6YW5kGrsrmV9e2aJlppn9KqNshXAHJ/DRdTaT6WyHZhg1WsB8IfnRA8EaztjLHs+Exd5gv+tQSEhOVruO3QUtwjKJinLmirWloVBWv/lkSCg0NoMzLd+xIhYh9EvOcGdqOlZCyDeEa0Oa5TQyffoFaYwj5JJNY9h/7OH6rXFTsWZBQXkQ/Cc7Vth2otaB5HnVN6icxzUty7GjUSLobXkTmsako/PGoHtcSuF1e+qC0iU3MqqvE444Bz4LP2n6bXvPJBqUc0PtUwirzra7v5P6WN8hVCzy1qT8WG+iv/XhlfcfLglt2KQFtX9wbTvmcCnP2rFGfAM8NvSXTyZ0kskFruvCIskXuW4sFG6kAnzeTOYFgndc1zoPeMbnnsvLbyME/kNcoeSm3p68Be11vX1CnHzj87pko4UrPhgQ7TwePxdrl96nU9pV4Th2J4ToFW4EKi0p52LuiRTaiwO41FLMa3bRHTmwSL/lnA10otGlLQ3VqVeOUGYZiwU72lK39deX4u+NX5YGTzqwd15x7YHlX9y9e7jHQNVRIh93LeskZRfZCUHgej1U+Oi63Hi6K9nOG7fgrxjRZiFA+5Og7hNw8jphP+bEzHbSi9oa7GYIQRPXjAGcsLKE6bFzBwKuGyGcbRCWMOArIxiLp2EWmcqVg6GJ/ceOvRaNn1PtXGXWqVZKqTzkSvGk4zqSMVleWlqqJ9Neql8KIRkaGPq0Zpg3wCI+gcPdfClaNY4990s5+33A4/bte5Cb+nZdD/5btqm/9IVduwZ7G2gK3d8uJX0E9iM2JNUBm2ZBQBr/5NFc6Zqa/E5YisFU0Fdba59tgFnar2lmgTTYl1PfVeMKSfcqj18ykmCCcwYOKISgFACwtyEEH8KJKCgYOCQxEuB8GpwX3EDyzVTehHDKyzVd50Swl1vrxh4kwmlESFHSQscWp6NPN9ZOulZrRnAeLPyrgbOnV6WjyWSsXwdceGD3OEOnj0ghidPdTXgwcOvA7GBCzGt2RDYL2zpEtYsOl4M7j/JlZWt+1e8f2f8foBwYWilcR7jUfUmtE46sUT4jTF9lOj6UOPukcJSPcFv8PQxGU5iuU/y0d3AnHtc0nQspe+9yeNhciqmuA9/YEu8k884rnZMlKfm6Y1thCMCrcK5wI7BtGtc5I+yeZPqUvku7c4qXzoaFeBg8jlKH3pfOSiSvg7i5yWPp+p99wFDNINXWMMMYSHDdqSKsKASdPDj+4MEbPKZ/XLciDGBWSVfgxSpqghfBebZLxE9IqG+P0uPR3zpn4tFCxtnNcJyass6djYHOhPU7xwl3wP/4asHEpfnJvDqIVe+6dgc2dkPemYLrvXk4WNBoQZiU+zD3rhqHnvd4yiOJMRoqOhoa/G77Yfekt663zpqm6QYcKrGnuX7LcTUuqL0dZtZmknz92gm3Z/fSJrXgZMGU36RpYiMQO21LeW/zu//RkkSVpqvsCS3KL636QV7p4h/2PFMW/2Ne6cK/JTD33qLPPOCJb++/k+p8rrDiQkOIO5yaIZy4P/EYqfrwjx/YJYT7Qk/YhAwX07S7JvHPKYfjihWus69xzTQAzzZP2pvfrWmBud6laYGhxHDvSH5Zd92EU1TSOoRUQUR1sXtYxZQw2ZPhHJ3hsvsIZXIfhEZirOceFlmkhONukpRCAGpStAYebwUCh4sW5ILj1Pp59wisRS0wGs20YRCg9EVCCQhlVepqcYS959Ql4vjk1QKCoWl8gm4Efm4Y5hM9jxb4GSP85yOtzgHemj4POK+2Nou5JIRNQKixmbiiDpxxeve4/W/OihsmjitCcHjOYU1Mi6FRFCZuTVHoqZ6XxtNfbnv06NkmDqoc5ixCbFkdv15ItlkKuDmSwZtOthohOMHufmVdXEZnqHV6kI+BOR0Fl7T2o8Pbz8pPI40Q0HbkCq7LGTQwZp2EYLfFNJyx3fHvUu28L85RzuadUNZPWMDa3jNfgzufsK0UGCCMK+8ZT2qoeSbkevyWWgjRfCRkfpREkraL+Ji4rrPHcsKzEh7bmgXcbz/xXvVZb2Gfntiw6LkyqgVKJRIYKQUHzkyTa0JUYW6XN/9eaPmHxWs2rNdN/Z9d20LY5BJumON1J/I90PzMo8u07h48ZLLG2QThuicgOeNzS6q+pHjhbsVl4gxD1NSFOHFa7tQPxra9RRIyThC2vULYUEZyY2wJoVOQMKBWJPwHxaPlw22nC0qr3tbMwDxcQ1MwVMuomIoDPBsN8wZFk1AGD5qJsDTHcax6GQ7eir3EFAaWRKmDgXEk6uXsnOLyEe0NNZ8krFUdbERQ8SfceZsgEG/o3HgcZvc8wp+nU2gTBtQVSFpba6tfTxhO0+lTgzXJurFTSU0dUQBPfGDnYH5VsuzTZL5WR2Qdkg/HvTw1tAJ3HP9B4conr0umvdw+ZL6CMo0iarlODwRqTDPwknpgprbpeuAZzrUBeALc1ual8O4KH4FgnIKvMDZ/YuUY3ONTlQACrr0erQJatXEn35JbvGgkpKEQHnpdcsIhRiPoAlXDMSsxgvr2nr0EzW2Gpv8CGSVsRctlJDBT0aUrgtJAc33NMVdEq2B8zuG3rc8rW7wwHW38GPbM4/uXavd5wA2v76mnjvNdabt7kYZs7H3cRuE4dVZX5yYr6j6azLxp3Yoz8GbXKuRUUWETwojPBQN05YWRDP+Onj0ImjHHdawumLUf2lFkcqzId73Hika+bTvO4+o6gXKUE3jA8W9SGgo1r9d1U5Oc3y4dMgXO0IkW/cz7vXTWfseyBSR3HOPyb3TN1CADKeY5Z9KCUXjHDFipVqS3lscySvF7saL3IR7eGDPTXHzmgbXVP7sP9/A3YYlcGPZncqYund27p8xbfZpoeL+iPhT6NdhvLK3dgXSdV3JJJBh0moqKkCJMX/gJvVoUOPfC+/6KRMiEOwNqwZYWr3nyNw2rH/hj+lV9j+YNGv5lXddHOW50Z0vtVuR7U4u6o8ODh82nXJuUb/BSuKQJ70K8uxcCcAeSMpX4R4Ux0pUvkEOvIct1ocDRPsrMa48hpr0eB3ivCq1gS3s03KNTOWSuBwYhOtoCU/mkNx5fZ5XO3znMoRWSsq+ojwun3qv+c/x8crutfus2eMEPwBJtIq7ckluy+Gtt9Vvg3KUWCHqKw5dK1f+PDbKubE5371PW3dfhqhfVbfw21ECsQqxqKXVSWgWDZUKi10wPhfoWrHQ7xZhGZaVy3nAoL16ChCivGvfmDk0zoAgunK3EAs91D7xm9fnrFsY0XRA3ZpI9qlNHft+Fr2MHEQlkQUhugmCe1O2ORm/+Ql3Occ9X4LdJRFixODxx/kKvu+6lNni8r8NLHsgNnvJRId2a1rr/fMa2oiF8er0GofSzeaWVJal0OF5KrisoWTK/oHjx3fFPfnHVPfklC2d4a/o00R5RpvXh1csPQHW34CKKscCXJ9zb/K/P02vSJiP6ek9W4fxcnMrd+LzW2SEDv++L1nXYi7GkhqSVBGY9njaok/chbCcRLlGYZwcKmqDhilZ9nFBCyZmu4p6GE++9gvi5t+RPyh4P5+pWIZz/lux8yvpeStVizytejJIlCQmWC99lEkkv9lrrq9c6VnQDvnDlMaLvzB1X2ZNZg4IIRcY1/WZk8l7kpvFC/IOvSzX4ohdzGhVdoiYhIVEya8YyqesziOMY2Bh+X7+LUtOPLDfyy6Zps054qxxLIoVpz4VDM1zdxarg/ltd9P1fvKbuao/us+rhWiACl/QRaO/x7oZ/b+2LvnVI89t5n+bfjzdlXZs13D0VR3zs0Nbz+SVLvoUwrwgpp9PtQ9uOxk3HmiazX45E6DKN8Wzk7g4kz0tbnHE1JHCE+1Zr/Y7u5Pn4vhWJvAar8SNAmeiMSrIpakU+lC55JZ7+YlsMiVjfPyvkW8gWDUdOrFcRo5E3bWksg/QF4dykno+MBVE9YdJFN+gC20kH9z+mmfpDSuJiQXiaN/c1hMCeWF3de/73ZMvs5oqKsEc7ae2GhwxDf0x9bVIlRmdZDx9e9b2fejR+fXUQ6JUM8GeMPiQQ84oo4lckMi73ccLdKryYPDQ3Nzd+u50fO0/Zlt2Eb5mxYYQpii4hQRJP77evHAIJB4x/nnscnmUsAM/kFRRf1GAzajs4b4tff2z9g+dhnlfiXJH+QiSLSdD1eY/Gr/fbmSOQcMANLadWIr79McC/4PleBl8lGMKy9lld4SXNN9/cY549FshT/xf+t/bv4MKctu3o+o4/f/Kv3pxf+wj4CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgI/D9F4P8A15R2TQhjgN0AAAAASUVORK5CYII=
description: Network Traffic Analysis
detaileddescription: 'All commands expect timestamps in the following format: "2000-01-01T00:00:00Z"'
configuration:
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Awake Security server address
  name: address
  defaultvalue: ""
  type: 0
  required: false
- display: Verify server certificate
  name: verify
  defaultvalue: "True"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Comma-separated threat behaviors to generate incidents for
  name: threat_behaviors
  defaultvalue: ""
  type: 0
  required: false
- display: Period (in minutes) between incident reports
  name: period
  defaultvalue: "60"
  type: 0
  required: false
- display: Minimum Threshold
  name: min_threshold
  defaultvalue: "33"
  type: 0
  required: false
- display: Maximum Threshold
  name: max_threshold
  defaultvalue: "66"
  type: 0
  required: false
script:
  script: |
    import base64
    import datetime
    import re
    import requests

    requests.packages.urllib3.disable_warnings()

    params = demisto.params()
    address = params["address"]
    prefix = address + "/awakeapi/v1"
    verify = params["verify"]
    credentials = params["credentials"]
    identifier = credentials["identifier"]
    password = credentials["password"]
    authTokenRequest = {
      "loginUsername": identifier,
      "loginPassword": password
    }
    authTokenResponse = requests.post(prefix + "/authtoken", json=authTokenRequest, verify=verify)
    authToken = authTokenResponse.json()["token"]["value"]
    headers = {
        "Authentication": ("access " + authToken)
    }
    command = demisto.command()
    args = demisto.args()
    request = {}

    # Convenient utility to marshal command arguments into the request body
    def slurp(fields):
        for field in fields:
            if field in args:
                request[field] = args[field]

    # Render a subset of the fields of the Contents as a markdown table
    def displayTable(contents, fields):
        # We don't use a set() because we want to preserve field order
        #
        # The fields are ordered to put the most relevant information first
        presentFields = []
        # Omit table columns that are all empty
        for content in contents:
            for field in fields:
                if field in content and content[field] and field not in presentFields:
                    presentFields.append(field)
        line0 = "| "
        line1 = "| "
        for field in presentFields:
            # Translate camel-case field names to title-case space-separated words
            tokens = re.findall("[a-zA-Z][A-Z]*[^A-Z]*", field)
            name = " ".join(map(lambda token: token.title(), tokens))
            line0 += name + " | "
            line1 += "--- | "
        line0 += "\n"
        line1 += "\n"
        body = ""
        for content in contents:
            body += "| "
            for field in presentFields:
                if field in content:
                    value = json.dumps(content[field])
                else:
                    value = ""
                body += value + " | "
            body += "\n"
        if presentFields:
            return (line0 + line1 + body)
        else:
            return "Empty results"

    def returnResults(contents, outerKey, innerKey, humanReadable, dbotScore):
        machineReadable = {
            "AwakeSecurity": contents,
        }

        entryContext = {
            ("AwakeSecurity." + outerKey + "(val." + innerKey + "===obj." + innerKey + ")"): contents,
        }

        if dbotScore is not None:
            machineReadable["DBotScore"] = dbotScore
            entryContext["DBotScore"] = dbotScore

        results = {
            "Type": 1,
            "ContentsFormat": "json",
            "Contents": json.dumps(machineReadable),
            "HumanReadable": humanReadable,
            "ReadableContentsFormat": "markdown",
            "EntryContext": entryContext,
        }

        demisto.results(results)

    def toDBotScore(indicator_type, percentile, lookup_key):
        if percentile <= 33:
            score = 1
        elif percentile <= 67:
            # Something doing something out of the ordinary
            score = 2
        else:
            # Probably bad or at least not compliant with
            # company policy.
            score = 3
        return {
            "Vendor": "Awake Security",
            "Type": indicator_type,
            "Indicator": lookup_key,
            "Score": score
        }

    def lookup(lookup_type, lookup_key):
        path = "/lookup/" + lookup_type
        request["lookup_key"] = lookup_key
        if "lookback_minutes" in args:
            request["lookback_minutes"] = int(args["lookback_minutes"])
        else:
            request["lookback_minutes"] = 480
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        return response.json()

    def lookupDevice(lookup_key):
        contents = lookup("device", lookup_key)

        humanReadableFields = [
            "deviceScore",
            "deviceName",
            "deviceType",
            "os",
            "osVersion",
            "commonEmail",
            "commonUsername",
            "tags",
            "recentIP",
            "activeIP",
            "nSimilarDevices",
            "ipCount",
            "applicationCount",
            "protocols",
            "firstSeen",
            "lastSeen",
        ]

        if "deviceScore" in contents:
            dbotScore = toDBotScore("device", contents["deviceScore"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'device',
                "Indicator": lookup_key,
                "Score": 0
            }

        humanReadable = displayTable([contents], humanReadableFields)

        contents["device"] = lookup_key

        returnResults(contents, "Devices", "device", humanReadable, dbotScore)

    def lookupDomain(lookup_key):
        contents = lookup("domain", lookup_key)

        humanReadableFields = [
            "notability",
            "isAlexaTopOneMillion",
            "isDGA",
            "intelSources",
            "numAssociatedDevices",
            "numAssociatedActivities",
            "approxBytesTransferred",
            "protocols",
            "firstSeen",
            "lastSeen",
        ]

        if "notability" in contents:
            dbotScore = toDBotScore("domain", contents["notability"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'domain',
                "Indicator": lookup_key,
                "Score": 0
            }

        humanReadable = displayTable([contents], humanReadableFields)

        contents["domain"] = lookup_key

        returnResults(contents, "Domains", "domain", humanReadable, dbotScore)

    def lookupEmail(lookup_key):
        contents = lookup("email", lookup_key)

        humanReadableFields = [
            "notabilityPercentile",
            "deviceName",
            "os",
            "deviceType",
            "application",
            "numberSimilarDevices",
            "numberSessions",
            "firstSeen",
            "lastSeen",
            "duration",
            "deviceId",
        ]

        if "notabilityPercentile" in contents:
            dbotScore = toDBotScore("email", contents["notabilityPercentile"], lookup_key)
        else:
            dbotScore = {
                "Vendor": "Awake Security",
                "Type": 'email',
                "Indicator": lookup_key,
                "Score": 0
            }

        humanReadable = displayTable(contents, humanReadableFields)

        for content in contents:
            content["email"] = lookup_key

        returnResults(contents, "Email", "email", humanReadable, dbotScore)

    def lookupIp(lookup_key):
        contents = lookup("ip", lookup_key)

        humanReadableFields = [
            "deviceCount",
            "activityCount",
            "ipFirstSeen",
            "ipLastSeen",
        ]

        dbotScore = {
            "Vendor": "Awake Security",
            "Type": 'ip',
            "Indicator": lookup_key,
            "Score": 0
        }

        # Note: No DBotScore for IP addresses as we do not score them.
        # Our product scores devices rather than IP addresses.
        humanReadable = displayTable([contents], humanReadableFields)

        contents["ip"] = lookup_key

        returnResults(contents, "IPs", "ip", humanReadable, dbotScore)

    def query(lookup_type):
        # Default to an empty query if unset
        request["queryExpression"] = ""

        slurp(["queryExpression", "startTime", "endTime"])

        nameMappings = [
            ("ipAddress","device.ip == {}"),
            ("deviceName","device.name like r/{}/"),
            ("domainName", "domain.name like r/{}/"),
            ("protocol", "activity.protocol == \"{}\""),
            ("tags","\"{}\" in device.tags"),
        ]

        for (name, mapping) in nameMappings:
            if name in args:
                if "queryExpression" in request and request["queryExpression"]:
                    request["queryExpression"] = request["queryExpression"] + " && " + mapping.format(args[name])
                else:
                    request["queryExpression"] = mapping.format(args[name])

        path = "/query/" + lookup_type
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        contents = response.json()

        return request["queryExpression"], contents

    def queryActivities():
        q, contents = query("activities")

        humanReadableFields = [
            "sourceIP",
            "sourceHost",
            "sourcePort",
            "destIP",
            "destHost",
            "destPort",
            "activityDeviceName",
            "activityStart",
            "activityEnd",
            "protocols",
        ]

        humanReadable = displayTable(contents, humanReadableFields)

        contents["query"] = q

        returnResults(contents, "Activities", "query", humanReadable, None)

    def queryDevices():
        q, contents = query("devices")

        humanReadableFields = [
            "notabilityPercentile",
            "deviceName",
            "os",
            "deviceType",
            "application",
            "numberSimilarDevices",
            "numberSessions",
            "firstSeen",
            "lastSeen",
            "duration",
            "deviceId",
        ]

        humanReadable = displayTable(contents, humanReadableFields)

        contents["query"] = q

        returnResults(contents, "Devices", "query", humanReadable, None)

    def queryDomains():
        q, contents = query("domains")

        humanReadableFields = [
            "name",
            "notability",
            "created",
            "lastUpdated",
            "expiration",
            "registrantOrg",
            "registrantCountry",
            "registrarName",
            "nameservers",
            "deviceCount",
            "intelCount",
            "lastSeen",
        ]

        humanReadable = displayTable(contents, humanReadableFields)

        contents["query"] = q

        returnResults(contents, "Domains", "query", humanReadable, None)

    def pcapDownload():
        slurp(["monitoringPointID"])
        session = {}
        for field in [ "hostA", "hostB", "startTimeRFC3339Nano", "endTimeRFC3339Nano" ]:
            if field in args:
                session[field] = args[field]
        if "startTimeRFC3339Nano" in args:
            session["startTimeRFC3339Nano"] = args["startTime"]
        if "endTimeRFC3339Nano" in args:
            session["endTimeRFC3339Nano"] = args["endTime"]
        for field in [ "protocol", "portA", "portB" ]:
            if field in args:
                session[field] = int(args[field])
        request["sessions"] = [ session ]
        path = "/pcap/download"
        response = requests.post(prefix + path, json=request, headers=headers, verify=verify)
        b64 = response.json()["pcap"]
        bytes = base64.b64decode(b64)
        demisto.results(fileResult("download.pcap", bytes))

    def fetchIncidents():
        threatBehaviorsString = params.get("threat_behaviors") or ""
        threatBehaviors = [ threatBehavior.strip() for threatBehavior in threatBehaviorsString.split(",")]
        if threatBehaviors == [""]:
            threatBehaviors = []
        lastRun = demisto.getLastRun();
        formatString = "%Y-%m-%d %H:%M:%S+0000"
        earlyTimeString = "1970-01-01 00:00:00+0000"
        startTimeString = lastRun.get("time") or earlyTimeString
        startTime = datetime.datetime.strptime(startTimeString, formatString)
        endTime = datetime.datetime.utcnow()
        endTimeString = datetime.datetime.strftime(endTime, formatString)
        if datetime.timedelta(minutes=int(params['period'])) <= endTime - startTime:
            jsonRequest = {
                "startTime": startTimeString,
                "endTime": endTimeString,
                "threatBehaviors": threatBehaviors
            }
            response = requests.post(prefix + "/threat-behavior/matches", json=jsonRequest, headers=headers, verify=verify)
            jsonResponse = response.json()
            matchingThreatBehaviors = jsonResponse.get("matchingThreatBehaviors", [])
            def toIncident(matchingThreatBehavior):
                # Currently the threat behavior API doesn't allow us to retrieve metadata for
                # the behaviors that matched, which is why this incident record is mostly empty
                #
                # However, we can provide the original query that the threat behavior corresponded
                # to plus the date range so that a playbook can feed them back into
                # `awake-query-{devices,activities}` to retrieving the matching devices or
                # activities that triggered the match to the threat behavior.
                return {
                    "Name": matchingThreatBehavior["name"],
                    "Query": matchingThreatBehavior["query"],
                    "StartTime": startTimeString,
                    "EndTime": endTimeString,
                }
            demisto.incidents(map(toIncident, matchingThreatBehaviors))
            # Don't increase the low-water-mark until we actually find incidents
            #
            # This is a precaution because incidents sometimes appear in an old time
            # bucket after a delay
            if 0 < len(matchingThreatBehaviors):
                lastRun = { "time": endTimeString }
        else:
            demisto.incidents([])
        demisto.setLastRun(lastRun)

    ''' EXECUTION '''
    LOG('command is %s' % (command))
    try:
        if command == "test-module":
            # If we got this far we already successfully authenticated against the server
            demisto.results('ok')
        elif command == "fetch-incidents":
            fetchIncidents()
        elif command == "awake-query-devices":
            queryDevices()
        elif command == "awake-query-activities":
            queryActivities()
        elif command == "awake-query-domains":
            queryDomains()
        elif command == "awake-pcap-download":
            pcapDownload()
        elif command == "domain":
            lookupDomain(args["domain"])
        elif command == "email":
            lookupEmail(args["email"])
        elif command == "ip":
            lookupIp(args["ip"])
        elif command == "device":
            lookupDevice(args["device"])
    except Exception, e:
        LOG(e.message)
        LOG.print_log()
  type: python
  commands:
  - name: awake-query-devices
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    outputs:
    - contextPath: AwakeSecurity.Devices.query.deviceId
      description: UUID that uniquely identifies the device
      type: string
    - contextPath: AwakeSecurity.Devices.query.deviceName
      description: Name of the device
      type: string
    - contextPath: AwakeSecurity.Devices.query.firstSeen
      description: Time that the device was first seen
      type: string
    - contextPath: AwakeSecurity.Devices.query.lastSeen
      description: Time that the device was last seen
      type: string
    - contextPath: AwakeSecurity.Devices.query.os
      description: Operating system
      type: string
    - contextPath: AwakeSecurity.Devices.query.deviceType
      description: Type of device
      type: string
    - contextPath: AwakeSecurity.Devices.query.ips
      description: List of IP addresses the device was seen using
      type: unknown
    - contextPath: AwakeSecurity.Devices.query.monitoringPointIds
      description: List of monitoring points the device was seen on
      type: unknown
    - contextPath: AwakeSecurity.Devices.query.application
      description: List of applications the device was seen using
      type: unknown
    - contextPath: AwakeSecurity.Devices.query.notabilityPercentile
      description: How the notability of this device compares to other devices
      type: number
    - contextPath: AwakeSecurity.Devices.query.numberSimilarDevices
      description: The number of other devices similar to this one
      type: number
    - contextPath: AwakeSecurity.Devices.query.numberSessions
      description: Number of TCP sessions for this device
      type: number
    - contextPath: AwakeSecurity.Devices.query.ackTime
      description: Time of last TCP acknowledgement seen for this device
      type: number
    - contextPath: AwakeSecurity.Devices.query.whiteListed
      description: Is this device whitelisted?
      type: bool
    description: Query devices
  - name: awake-query-activities
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    outputs:
    - contextPath: AwakeSecurity.Activities.query.activityId
      description: UUID that uniquely identifies the activity
      type: string
    - contextPath: AwakeSecurity.Activities.query.sessionId
      description: UUID that uniquely identifies the corresponding session
      type: string
    - contextPath: AwakeSecurity.Activities.query.sourceIP
      description: IP address of the source
      type: string
    - contextPath: AwakeSecurity.Activities.query.sourceHost
      description: Hostname of the source
      type: string
    - contextPath: AwakeSecurity.Activities.query.sourcePort
      description: Port of the source
      type: number
    - contextPath: AwakeSecurity.Activities.query.destinationIP
      description: IP address of the destination
      type: string
    - contextPath: AwakeSecurity.Activities.query.destinationHost
      description: Hostname of the destination
      type: string
    - contextPath: AwakeSecurity.Activities.query.destinationPort
      description: Port of the destination
      type: number
    - contextPath: AwakeSecurity.Activities.query.directionKnown
      description: Do we know for sure which endpoint was the client?
      type: bool
    - contextPath: AwakeSecurity.Activities.query.activityDeviceName
      description: Device name for the endpoint within your network
      type: string
    - contextPath: AwakeSecurity.Activities.query.activityStart
      description: Time when the activity began
      type: string
    - contextPath: AwakeSecurity.Activities.query.activityEnd
      description: Time when the activity ended
      type: string
    - contextPath: AwakeSecurity.Activities.query.protocols
      description: Protocols that the activity used
      type: unknown
    description: Query activities
  - name: awake-query-domains
    arguments:
    - name: queryExpression
      description: A query expression in the Awake Query Language
    - name: startTime
      required: true
      description: Beginning of the time range to query
    - name: endTime
      required: true
      description: End of the time range to query
    - name: ipAddress
      description: IP address (Exact match)
    - name: deviceName
      description: Name of the device (Regular expression)
    - name: domainName
      description: Name of the domain (Regular expression)
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: tag
      description: Tag to match (Regular expression)
    outputs:
    - contextPath: AwakeSecurity.Domains.query.name
      description: Name of the domain
      type: string
    - contextPath: AwakeSecurity.Domains.query.created
      description: Time the domain was created
      type: string
    - contextPath: AwakeSecurity.Domains.query.lastUpdated
      description: Time the domain was last updated
      type: string
    - contextPath: AwakeSecurity.Domains.query.registrantOrg
      description: Organization of the registrant
      type: string
    - contextPath: AwakeSecurity.Domains.query.registrantCountry
      description: Country of the registrant
      type: string
    - contextPath: AwakeSecurity.Domains.query.registrarName
      description: Name of the registrar
      type: string
    - contextPath: AwakeSecurity.Domains.query.whoisServer
      description: Address of the WHOIS server
      type: string
    - contextPath: AwakeSecurity.Domains.query.whoisFound
      description: Was this domain found via WHOIS?
      type: bool
    - contextPath: AwakeSecurity.Domains.query.deviceCount
      description: Number of devices currently interacting with this domain
      type: number
    - contextPath: AwakeSecurity.Domains.query.totalDevices
      description: Total number of devices that have interacted with this domain
      type: number
    - contextPath: AwakeSecurity.Domains.query.intelCount
      description: Number of matches of imported intel against this domain
      type: number
    - contextPath: AwakeSecurity.Domains.query.lastSeen
      description: Time of the most recent interaction with that domain
      type: number
    - contextPath: AwakeSecurity.Domains.query.nameservers
      description: List of authoritative nameservers for that domain
      type: unknown
    - contextPath: AwakeSecurity.Domains.query.notability
      description: Notability of the domain (higher means more unusual activity)
      type: number
    - contextPath: AwakeSecurity.Domains.query.whiteListed
      description: Is this domain whitelisted?
      type: bool
    description: Query domains
  - name: awake-pcap-download
    arguments:
    - name: protocol
      description: Protocol (all uppercase, i.e. "TLS")
    - name: hostA
      description: First host's address
    - name: hostB
      description: Second host's address
    - name: portA
      description: First host's port
    - name: portB
      description: Second host's port
    - name: startTime
      description: Beginning of the time range to query
    - name: endTime
      description: End of the time range to query
    description: Download a PAP
  - name: domain
    arguments:
    - name: domain
      required: true
      description: The domain name
    - name: lookback_minutes
      description: How many minutes of history to query
    outputs:
    - contextPath: AwakeSecurity.Domains.domain.approxBytesTransferred
      description: Approximate bytes the indicator passed
      type: number
    - contextPath: AwakeSecurity.Domains.domain.DomainWithSameRegistrant
      description: Domain with same registrant to the domain
      type: unknown
    - contextPath: AwakeSecurity.Domains.domain.DomainWithSameRegistrant.firstSeen
      description: First time the domain with same registrant to the domain was seen
      type: string
    - contextPath: AwakeSecurity.Domains.domain.IntelSources
      description: Intel sources
      type: string
    - contextPath: AwakeSecurity.Domains.domain.ipAddresses
      description: Ip addresses
      type: string
    - contextPath: AwakeSecurity.Domains.domain.isAlexaTopOneMillion
      description: Alexa data
      type: string
    - contextPath: AwakeSecurity.Domains.domain.isDGA
      description: is the indicator DGA
      type: boolean
    - contextPath: AwakeSecurity.Domains.domain.lastSeen
      description: Last time the indicator was seen
      type: string
    - contextPath: AwakeSecurity.Domains.domain.notabillity
      description: Notability score
      type: number
    - contextPath: AwakeSecurity.Domains.domain.numAssociatedActivities
      description: Number of associated activities
      type: number
    - contextPath: AwakeSecurity.Domains.domain.numAssociatedADevices
      description: Number of associated devices
      type: number
    - contextPath: AwakeSecurity.Domains.domain.protocols
      description: Related protocols
      type: string
    - contextPath: AwakeSecurity.Domains.domain.relatedSubdomains
      description: Related subdomains
      type: string
    - contextPath: AwakeSecurity.Domains.domain.subdomains
      description: Subdomains
      type: string
    - contextPath: AwakeSecurity.Domains.domain.topDevices
      description: Top Devices
      type: string
    - contextPath: AwakeSecurity.Domains.domain.totalNumDevices
      description: Total number of devices
      type: number
    - contextPath: AwakeSecurity.Domains.domain.whiteListed
      description: Is in white list
      type: boolean
    - contextPath: DBotScore.Indicator
      description: Indicator of the domain
      type: string
    - contextPath: DBotScore.Score
      description: Score of the domain
      type: number
    - contextPath: DBotScore.Type
      description: Type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor of the data
      type: string
    description: Lookup a domain
  - name: ip
    arguments:
    - name: ip
      required: true
      description: The IP address
    - name: lookback_minutes
      description: How many minutes of history to query
    outputs:
    - contextPath: AwakeSecurity.IPs.ip.activityCount
      description: Activity count of the ip
      type: number
    - contextPath: AwakeSecurity.IPs.ip.deviceCount
      description: device count of the ip
      type: number
    - contextPath: AwakeSecurity.IPs.ip.devices
      description: Devices of the ip
      type: unknown
    - contextPath: AwakeSecurity.IPs.ip.domains
      description: domains of the ip
      type: unknown
    - contextPath: AwakeSecurity.IPs.ip.ipFirstSeen
      description: First time the ip was seen
      type: string
    - contextPath: AwakeSecurity.IPs.ip.ipLastSeen
      description: Last time the ip was seen
      type: string
    - contextPath: DBotScore.Indicator
      description: Indicator of the ip
      type: string
    - contextPath: DBotScore.Score
      description: Score of the ip
      type: number
    - contextPath: DBotScore.Vendor
      description: Vendor of the data
      type: string
    - contextPath: DBotScore.Type
      description: Type of the indicator
      type: string
    description: Lookup an IP address
  - name: email
    arguments:
    - name: email
      description: The email address
    - name: lookback_minutes
      description: How many minutes of history to query
    outputs:
    - contextPath: AwakeSecurity.Emails.email.deviceId
      description: Device ID associated with this email address
      type: string
    - contextPath: AwakeSecurity.Emails.email.deviceName
      description: Device name associated with this email address
      type: string
    - contextPath: AwakeSecurity.Emails.email.firstSeen
      description: Time this email address was first seen
      type: string
    - contextPath: AwakeSecurity.Emails.email.lastSeen
      description: Time this email address was last seen
      type: string
    - contextPath: AwakeSecurity.Emails.email.duration
      description: Duration that this email address was seen
      type: string
    - contextPath: AwakeSecurity.Emails.email.os
      description: Operating system associated with this email address
      type: string
    - contextPath: AwakeSecurity.Emails.email.deviceType
      description: Device type associated with this email address
      type: string
    - contextPath: AwakeSecurity.Emails.email.ips
      description: IP addresses associated with this email address
      type: unknown
    - contextPath: AwakeSecurity.Emails.email.monitoringPointIds
      description: Monitoring points that this email address was seen on
      type: string
    - contextPath: AwakeSecurity.Emails.email.application
      description: Email application(s) associated with this email address
      type: unknown
    - contextPath: AwakeSecurity.Emails.email.notabilityPercentile
      description: Notability of this email address (higher means more unusual activity)
      type: number
    - contextPath: AwakeSecurity.Emails.email.numberSimilarDevices
      description: Number of similar devices associated with this email addresses
      type: number
    - contextPath: AwakeSecurity.Emails.email.numberSessions
      description: Number of TCP sessions associated with this email address
      type: number
    - contextPath: AwakeSecurity.Emails.email.ackTime
      description: Time of last TCP acknowledgment associated with this email address
      type: string
    - contextPath: AwakeSecurity.Emails.email.whiteListed
      description: Is this email address whitelisted?
      type: bool
    - contextPath: DBotScore.Score
      description: Score of the domain
      type: number
    - contextPath: DBotScore.Type
      description: Type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor of the data
      type: string
    description: Lookup an email address
  - name: device
    arguments:
    - name: device
      required: true
      description: The device ID
    - name: lookback_minutes
      description: How many minutes of history to query
    outputs:
    - contextPath: AwakeSecurity.Devices.device.deviceScore
      description: Score for the device (higher means more unusual activity)
      type: number
    - contextPath: AwakeSecurity.Devices.device.notableDomainCount.value
      description: Number of suspect destinations associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.notableDomainCount.percentile
      description: How this device compares to other devices with respect to suspect
        destinations
      type: number
    - contextPath: AwakeSecurity.Devices.device.notableDomainCount.weight
      description: How much suspect destinations contributed to the device's score
      type: number
    - contextPath: AwakeSecurity.Devices.device.iocCount.value
      description: Number of IOCs associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.iocCount.percentile
      description: How this device compares to other devices with respect to IOCs
      type: number
    - contextPath: AwakeSecurity.Devices.device.iocCount.weight
      description: How much IOCs contributed to the device's score
      type: number
    - contextPath: AwakeSecurity.Devices.device.watchlistCount.value
      description: Number of threat behaviors associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.watchlistCount.percentile
      description: How this device compares to other devices with respect to threat
        behaviors
      type: number
    - contextPath: AwakeSecurity.Devices.device.watchlistCount.weight
      description: How much threat behaviors contributed to the device's score
      type: number
    - contextPath: AwakeSecurity.Devices.device.activityCount.value
      description: Number of characteristic artifacts associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.activityCount.percentile
      description: How this device compares to other devices with respect to characteristic
        artifacts
      type: number
    - contextPath: AwakeSecurity.Devices.device.activityCount.weight
      description: How much characteristic artifacts contributed to the device's score
      type: number
    - contextPath: AwakeSecurity.Devices.device.deviceName
      description: Name of the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.deviceType
      description: Type of device
      type: string
    - contextPath: AwakeSecurity.Devices.device.os
      description: Operating system associated with the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.recentIp
      description: Most recent IP address associated with the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.activeIp
      description: Most common IP address associated with the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.commonEmail
      description: Most common email address associated with the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.commonUsername
      description: Most common username associated with the device
      type: string
    - contextPath: AwakeSecurity.Devices.device.commonMpid
      description: Most common monitoring point the device was seen on
      type: string
    - contextPath: AwakeSecurity.Devices.device.nSimilarDevices
      description: How many other devices are similar to this one
      type: number
    - contextPath: AwakeSecurity.Devices.device.tags
      description: Tags associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.ipCount
      description: Number of IP addresses associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.emailCount
      description: Number of email addresses associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.usernameCount
      description: Number of usernames associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.applicationCount
      description: Number of applications associated with this device
      type: number
    - contextPath: AwakeSecurity.Devices.device.mpids
      description: List of monitoring points associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.protocols
      description: Protocols and their counts associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.firstSeen
      description: Time that this device was first seen
      type: string
    - contextPath: AwakeSecurity.Devices.device.lastSeen
      description: Time that this device was last seen
      type: string
    - contextPath: AwakeSecurity.Devices.device.osVersion
      description: Operating system version
      type: string
    - contextPath: AwakeSecurity.Devices.device.deviceGuid
      description: UUID that the Awake Security product uses to uniquely identify
        this device
      type: string
    - contextPath: AwakeSecurity.Devices.device.ips
      description: List of IP addresses and metadata associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.usernames
      description: List of usernames associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.emails
      description: List of emails associated with this device
      type: unknown
    - contextPath: AwakeSecurity.Devices.device.ackTs
      description: Time of last TCP acknowledgment associated with this device
      type: string
    - contextPath: AwakeSecurity.Devices.device.ackTs
      description: Is this device whitelisted?
      type: bool
    description: Lookup a device
  isfetch: true
  runonce: false
